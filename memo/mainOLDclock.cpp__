#include <WiFi.h>
#include <SPIFFS.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include "Preferences.h"
#include <NTPClient.h>
#include <si5351.h>
#include <JTEncode.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <time.h>
#include <ArduinoJson.h>
#include <ESPmDNS.h> // Library to enable mDNS (Multicast DNS) for resolving local hostnames like "device.local"
#define SI5351_SDA 25
#define SI5351_SCL 26
#define VERSION "Beta 0"

// Wi-Fi credentials
const char *ssid = "NO WIFI FOR YOU!!!";
const char *password = "Nestle2010Nestle";

char call[8]; // USER CALLSIGN will be retrieved through preferences
char loc[7];  // USER MAIDENHEAD GRID LOCATOR first 6 letters.
uint32_t power_mW;
uint8_t dbm = 24;

// Create the Si5351 object
Si5351 si5351;
// Create the jtencode object
JTEncode jtencode;

// Create a Preferences object for storing and retrieving key-value
Preferences preferences;


// Calibration variables
int32_t cal_factor = 0;
int calFrequencyInMhz = 0;

bool warmingup = false;
unsigned long long WSPR_TX_operatingFrequ;
unsigned long long TX_referenceFrequ = 0;
TaskHandle_t txCounterTaskHandle = NULL;
// Timing variables
volatile bool isFirstIteration = true;
volatile bool interruptWSPRcurrentTX = false;
struct tm timeinfo;
time_t currentEpochTime;
time_t nextPosixTxTime;
time_t currentRemainingSeconds;
time_t intervalBetweenTx = 120;
int modeOfOperation = 2;// inherited from MLA toolbox
byte selectedBandIndex = 3;// inherited from MLA toolbox
unsigned long now;
// TX status
bool tx_is_ON = false;
int tx_ON_running_time_in_s = 0;
// Define UDP client for NTP
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "time-a-g.nist.gov");

#define TONE_SPACING 146 // ~1.46 Hz
#define WSPR_DELAY 683   // Delay value for WSPR
#define WSPR_CTC 10672   // CTC value for WSPR
#define SYMBOL_COUNT WSPR_SYMBOL_COUNT

#define SEND_INTV 10
#define RECV_TIMEOUT 10

#define SI5351_REF 25000000UL // si5351‚Äôs crystal frequency, 25 Mhz or 27 MHz
uint8_t tx_buffer[SYMBOL_COUNT];

// Async web server runs on port 80
AsyncWebServer server(80);

// prototypes

void initializeTimeClient();
void initSI5351();
String convertPosixToHHMMSS(time_t posixTime);
void si5351_WarmingUp();
void transmitWSPR();
void startTransmission();
String formatFrequencyWithDots(unsigned freq);
void TX_ON_counter_core0(void *parameter);
// ################################################################################################
// Prototype declarations
// related to WSPR
// ‚úÖ WSPR Band Definitions (Hz) from official sub-band plan
// https://www.wsprnet.org/drupal/sites/wsprnet.org/files/wspr-qrg.pdf
const char *WSPRbandNames[] = {
    "80m", "40m", "30m", "20m", "17m", "15m", "12m", "10m"};

const unsigned long WSPRbandStart[] = {
    3570000, 7040000, 10140100, 14097000, 18106000, 21096000, 24926000, 28126000};

const unsigned long WSPRbandEnd[] = {
    3570200, 7040200, 10140300, 14097200, 18106200, 21096200, 24926200, 28126200};

const byte numWSPRbands = sizeof(WSPRbandNames) / sizeof(WSPRbandNames[0]);

// ‚úÖ Returns a randomized safe WSPR transmit frequency for a given band index
unsigned long setRandomWSPRfrequency(byte bandIndex);
void displaySelecetdBandInformation(byte bandIndex);

void initializeNextTransmissionTime();
void retrieveUserSettings();
void updateNTPTime();
void configure_web_server();
void setFrequencyInMhz(float freqMHz);
//----------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------
void setup()
{
    Serial.begin(115200);

    // Initialize SPIFFS
    if (!SPIFFS.begin(true))
    {
        Serial.println("An error occurred while mounting SPIFFS");
        return;
    }
    Serial.println("SPIFFS mounted successfully");
    // Connect to Wi-Fi
    WiFi.begin(ssid, password);
    Serial.print("Connecting to Wi-Fi");
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nConnected to Wi-Fi");
    Serial.println(WiFi.localIP());
    // Retrieve user settings
    retrieveUserSettings();
    updateNTPTime();

    // init RF module
    initSI5351();

    // Start server
   
    configure_web_server();
}
//---------------------------------------------------------------------------------------------
void loop()
{
    // First-time initialization
    if (isFirstIteration)
    {
        Serial.println("\nüîÅ First Loop Iteration: Determining next TX start time...");
        intervalBetweenTx = 2 * 60; // 2 minutes for WSPR
        initializeNextTransmissionTime();
        isFirstIteration = false;
        interruptWSPRcurrentTX = false;
                    TX_referenceFrequ = WSPRbandStart[selectedBandIndex]; // TEMPORARY

    }

    // Get current time once per loop
    timeClient.update();
    currentEpochTime = timeClient.getEpochTime();

    Serial.print("\nüïí Current time: ");
    Serial.println(convertPosixToHHMMSS(currentEpochTime));
    Serial.print("üïë Next TX Time: ");
    Serial.println(convertPosixToHHMMSS(nextPosixTxTime));

    displaySelecetdBandInformation(selectedBandIndex);

    // Countdown loop until it's time to transmit or interrupted
    while (currentEpochTime < nextPosixTxTime && !interruptWSPRcurrentTX)
    {
        //timeClient.update();
        currentEpochTime = timeClient.getEpochTime();
        currentRemainingSeconds = nextPosixTxTime - currentEpochTime;

        Serial.print("\r‚è≥ TX starts in ");
        Serial.print(currentRemainingSeconds);
        Serial.print(" s   "); // overwrite line

        // Start warming up ~5 seconds before TX
        if (currentRemainingSeconds <= 5 && !warmingup)
        {
            si5351_WarmingUp();
        }

        delay(500); // Don't spin too fast
    }

    // If interrupted, skip TX
    if (interruptWSPRcurrentTX)
    {
        Serial.println("\n‚ö†Ô∏è TX Interrupted! Skipping transmission...");
        return;
    }

    // Transmission time reached
    Serial.println("\nüöÄ Starting WSPR Transmission...");

    // Update for the next TX slot (every 2 minutes)
    nextPosixTxTime += intervalBetweenTx;

    // Begin transmission
    startTransmission();

    // Shutdown Si5351 output after TX
    si5351.set_clock_pwr(SI5351_CLK0, 0);
    Serial.println("üì¥ --- TX OFF: Transmission Complete ---\n");
}

//---------------------------------------------------------------------------------------------

void initSI5351()
{
    const uint8_t SI5351_ADDRESS = 0x60;

    // üîå Start I¬≤C bus at 400 kHz (fast mode) ‚Äî reliable and quick on ESP32
    Wire.begin(SI5351_SDA, SI5351_SCL);
    Wire.setClock(400000);

    // üîç Probe Si5351 I¬≤C address to check if device is present
    Wire.beginTransmission(SI5351_ADDRESS);
    if (Wire.endTransmission() != 0)
    {
        Serial.println("‚ùå Si5351 not found at 0x60. Check wiring or power.");
        return;
    }

    // ‚úÖ Found and ready to initialize
    Serial.println("‚úÖ Success! Si5351 module found!! üéâ");
    Serial.println("üì° Initializing Si5351...");

    // ‚öôÔ∏è Initialize Si5351 with 8pF crystal load (typical for cheap boards)
    si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0); // 0, 0 = use default XTAL + correction

    // üîß Apply frequency calibration correction (in parts per billion)
    Serial.print("üîß Applying Calibration Factor: ");
    Serial.println(cal_factor);
    si5351.set_correction(cal_factor, SI5351_PLL_INPUT_XO);

    // üì∂ Set frequency for selected TX clock output (CLK0, CLK1, or CLK2)
    Serial.print("üì∂ Setting TX Reference Frequency: ");
    Serial.print(TX_referenceFrequ);
    Serial.println(" Hz");
    si5351.set_freq(TX_referenceFrequ, SI5351_CLK0);

    // üí™ Set drive strength for the selected clock output (strongest = 8 mA)
    si5351.drive_strength(SI5351_CLK0, SI5351_DRIVE_8MA);

    // üì¥ Disable all unused outputs among CLK0, CLK1, and CLK2
    Serial.println("üîå Disabling unused clock outputs: ");
    bool first = true;
    si5351_clock clocks[] = {SI5351_CLK0, SI5351_CLK1, SI5351_CLK2};

    for (si5351_clock clk : clocks)
    {
        si5351.set_clock_pwr(clk, 0); // Disable unused clock output
        // Serial.print("Disabling CLK");
        // Serial.println((int)clk); // newline for better readability
    }
    Serial.println();
    // switch OFF
    si5351.set_clock_pwr(SI5351_CLK0, 0);
}
void initializeNextTransmissionTime()
{
    timeClient.update();
    // üïí Get Current Epoch Time
    currentEpochTime = timeClient.getEpochTime();
    int currentHour = (currentEpochTime % 86400L) / 3600;
    int currentMinute = (currentEpochTime % 3600) / 60;
    int currentSecond = currentEpochTime % 60;

    // üóìÔ∏è Determine Next Even Minute
    int nextEvenMinute = (currentMinute % 2 == 0) ? currentMinute + 2 : currentMinute + 1;
    int nextHour = currentHour;

    // ‚è≠Ô∏è Handle Hour Rollover
    if (nextEvenMinute >= 60)
    {
        nextEvenMinute = 0;
        nextHour = (currentHour + 1) % 24;
    }

    // üìÖ Calculate Next Transmission Time
    if (nextHour != currentHour)
    {
        nextPosixTxTime = currentEpochTime + ((60 - currentMinute) * 60 - currentSecond) + (nextEvenMinute * 60);
    }
    else
    {
        nextPosixTxTime = currentEpochTime + (nextEvenMinute - currentMinute) * 60 - currentSecond;
    }

    // ‚úÖ Log the Result
    Serial.print("üìÖ Next Transmission Time (POSIX): ");
    Serial.println(nextPosixTxTime);
    Serial.print("üïë Next TX Time (Human Readable):  ");
    Serial.println(convertPosixToHHMMSS(nextPosixTxTime));
}

String convertPosixToHHMMSS(time_t posixTime)
{
    // Convert epoch time to struct tm
    struct tm *timeInfo;
    timeInfo = localtime(&posixTime); // Use localtime() for local time or gmtime() for UTC time

    // Format the time
    char formattedTime[9]; // HH:MM:SS + null terminator
    sprintf(formattedTime, "%02d:%02d:%02d", timeInfo->tm_hour, timeInfo->tm_min, timeInfo->tm_sec);

    // Return formatted time as String
    return String(formattedTime);
}
void updateNTPTime()
{
    const int maxAttempts = 10;
    const unsigned long timeoutMs = 5000;
    const char *fallbackServers[] = {
        "pool.ntp.org",
        "time.nist.gov",
        "europe.pool.ntp.org"};
    const int numFallbacks = sizeof(fallbackServers) / sizeof(fallbackServers[0]);

    Serial.println("‚è∞ Attempting to update NTP time...");

    for (int serverIndex = 0; serverIndex < numFallbacks; serverIndex++)
    {
        timeClient.setPoolServerName(fallbackServers[serverIndex]);
        initializeTimeClient(); // Re-initialize with new server
        Serial.print("üåê Trying NTP server: ");
        Serial.println(fallbackServers[serverIndex]);

        unsigned long startTime = millis();
        int attempts = 0;

        while (attempts < maxAttempts)
        {
            if (timeClient.update())
            {
                Serial.print("‚úÖ NTP time updated successfully: ");
                Serial.println(timeClient.getFormattedTime());
                return; // Success!
            }

            if (millis() - startTime > timeoutMs)
            {
                Serial.println("‚è≥ Timeout exceeded. Moving to next server...");
                break;
            }
            delay(1500); // Wait before retrying
            attempts++;
        }
    }

    // All servers failed
    Serial.println("‚ùå NTP time could not be updated after trying all servers.");
    Serial.println("üîÑ Rebooting system...");
    delay(2000); // Allow time for messages to be read
    esp_restart();
}
void initializeTimeClient()
{
    Serial.println("‚è∞ Initializing NTP Time Client...");
    timeClient.begin();
    /*
    timeClient.setTimeOffset(timeOffset * 3600);

    Serial.print("üåç Time Offset set to: ");
    Serial.print(timeOffset);
    Serial.println(" hour(s) ‚è±Ô∏è");
  */
    Serial.println("‚úÖ NTP Time Client Ready!");
}

void si5351_WarmingUp()
{
    warmingup = true;
    Serial.println();
    Serial.println("üî• Radio Module 'Warming Up' Started...");

    // üéõÔ∏è Apply small random frequency offset (-100 to +100 Hz)

    WSPR_TX_operatingFrequ = setRandomWSPRfrequency(selectedBandIndex) * 100ULL; /// Hz * 100 for module

    // üì° Log the new TX frequency with formatting
    Serial.print("üì∂ Setting TX Frequency to: ");
    Serial.print(formatFrequencyWithDots(WSPR_TX_operatingFrequ / 100ULL));
    Serial.print("     (ref. ");
    Serial.print(formatFrequencyWithDots(TX_referenceFrequ));
    Serial.println(")");
    // ‚öôÔ∏è Configure Si5351 for transmission
    si5351.set_freq(WSPR_TX_operatingFrequ, SI5351_CLK0);
    si5351.set_clock_pwr(SI5351_CLK0, 1); // Power ON
}

void startTransmission()
{
    tx_is_ON = true;

    xTaskCreatePinnedToCore(
        TX_ON_counter_core0,  // Task function
        "TXCounterTask",      // Name of the task
        1536,                 // Stack size in words
        NULL,                 // Task input parameter
        1,                    // Priority of the task
        &txCounterTaskHandle, // Task handle
        0                     // Core to pin the task to (0 in this case)
    );

    transmitWSPR();
    tx_is_ON = false;
    tx_ON_running_time_in_s = 0;

    // Wait for the task to complete and clean up
    vTaskDelete(txCounterTaskHandle);
    txCounterTaskHandle = NULL;
}

// ‚úÖ Returns a randomized safe WSPR transmit frequency for a given band index
unsigned long setRandomWSPRfrequency(byte bandIndex)
{
    unsigned long officialStart = WSPRbandStart[bandIndex];
    unsigned long officialEnd = WSPRbandEnd[bandIndex];
    unsigned long minF = officialStart + 3;
    unsigned long maxF = officialEnd - 3;

    unsigned long freq = random(minF, maxF + 1); // inclusive range

    Serial.printf("üéØ Selected random freq within available range:  %lu Hz\n", freq);

    return freq;
}

String formatFrequencyWithDots(unsigned freq)
{
    String s = String(freq);
    int len = s.length();

    // Insert dots every 3 digits from the right
    for (int i = len - 3; i > 0; i -= 3)
    {
        s = s.substring(0, i) + "." + s.substring(i);
    }

    return s;
}

void TX_ON_counter_core0(void *parameter)
{
    tx_ON_running_time_in_s = 0;

    while (tx_is_ON == true)
    {
        tx_ON_running_time_in_s = tx_ON_running_time_in_s + 1;
        // The transmission occupies exactly 110.592 seconds ( rounded to 110).

        // Serial.printf("TX ON counter: %d seconds\n", tx_ON_running_time_in_s);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }

    // Delete the task if tx_is_ON is false to free resources
    vTaskDelete(NULL);
    txCounterTaskHandle = NULL;
}

void displaySelecetdBandInformation(byte bandIndex)
{
    unsigned long officialStart = WSPRbandStart[bandIndex];
    unsigned long officialEnd = WSPRbandEnd[bandIndex];
    unsigned long minF = officialStart + 3;
    unsigned long maxF = officialEnd - 3;

    Serial.println();
    Serial.println("üì∂ --- WSPR Transmission Setup --------------------------------------");

    Serial.printf("üîπ Band:            %s\n", WSPRbandNames[bandIndex]);
    Serial.printf("üîπ Sub-band:        %lu ‚Äì %lu Hz\n", officialStart, officialEnd);
    Serial.printf("üîπ Usable range:    %lu ‚Äì %lu Hz (excludes ¬±3 Hz edges)\n", minF, maxF);
    Serial.println("üîπ Bandwidth used:  ~6 Hz centered around selected frequency");
    Serial.printf("üßæ Callsign:        %s\n", call);
    Serial.printf("üåç Locator:         %s\n", loc);
    Serial.printf("‚ö° Power:           %lu mW\n", power_mW);

    Serial.println("---------------------------------------------------------------------");
    Serial.println();
}
void transmitWSPR()
{
    uint8_t i;

    // üéôÔ∏è Encode WSPR message
    jtencode.wspr_encode(call, loc, dbm, tx_buffer);

    // üöÄ Transmission Start
    Serial.println("\nüì° --- TX ON: Starting Transmission ---");

    // üîä Transmit each WSPR symbol
    for (int i = 0; i < SYMBOL_COUNT; i++)
    {
        uint64_t toneFreq = WSPR_TX_operatingFrequ + (tx_buffer[i] * TONE_SPACING);
        si5351.set_freq(toneFreq, SI5351_CLK0);
        delay(WSPR_DELAY);
        if (interruptWSPRcurrentTX == true)
        {
            break; // Exit the for loop
        }
    }

    warmingup = false;
}

void retrieveUserSettings()
{
    Serial.println("üìÇ Loading user settings from NVS...");

    // ‚úÖ Open preferences namespace
    preferences.begin("settings", false);

    // üì° Retrieve Callsign
    String storedCall = preferences.getString("callsign");
    if (storedCall.isEmpty())
    {
        Serial.println("‚ö†Ô∏è Callsign not found! Setting default to 'NOCALL' üÜï");
        storedCall = "NOCALL";
        preferences.putString("callsign", storedCall);
    }
    else
    {
        Serial.println("‚úÖ Callsign retrieved successfully.");
    }
    storedCall.toCharArray(call, sizeof(call));
    Serial.printf("üì¢ Callsign: %s\n", call);

    // üåç Retrieve Locator
    String storedLoc = preferences.getString("locator");
    if (storedLoc.isEmpty())
    {
        Serial.println("‚ö†Ô∏è Locator not found! Setting default to 'XX00XX' üÜï");
        storedLoc = "XX00XX";
        preferences.putString("locator", storedLoc);
    }
    else
    {
        Serial.println("‚úÖ Locator retrieved successfully.");
    }
    storedLoc.toCharArray(loc, sizeof(loc));
    Serial.printf("üì¢ Locator: %s\n", loc);

    // ‚ö° Retrieve Power in mW
    power_mW = preferences.getUInt("power", 0);
    if (power_mW == 0)
    {
        Serial.println("‚ö†Ô∏è Power value not found! Setting default to 250 mW üÜï");
        power_mW = 250;
        preferences.putUInt("power", power_mW);
    }
    else
    {
        Serial.println("‚úÖ Power retrieved successfully.");
    }
    dbm = round(10 * log10(power_mW));
    Serial.printf("üì¢ Power: %d mW ‚Üí %d dBm\n", power_mW, dbm);

    // ‚è≤Ô∏è Retrieve Schedule State
    String scheduleState = preferences.getString("scheduleState");
    if (scheduleState.isEmpty())
    {
        Serial.println("‚ö†Ô∏è Schedule state not found! Setting default to 2 minutes üÜï");
        scheduleState = "schedule1";
        preferences.putString("scheduleState", scheduleState);
    }
    else
    {
        Serial.println("‚úÖ Schedule state retrieved successfully.");
    }

    if (scheduleState == "schedule1")
        intervalBetweenTx = 2 * 60;
    else if (scheduleState == "schedule2")
        intervalBetweenTx = 4 * 60;
    else if (scheduleState == "schedule3")
        intervalBetweenTx = 6 * 60;
    else if (scheduleState == "schedule4")
        intervalBetweenTx = 8 * 60;
    else if (scheduleState == "schedule5")
        intervalBetweenTx = 10 * 60;
    else
        intervalBetweenTx = 2 * 60;

    Serial.printf("üì¢ Transmission Interval: %d seconds (%d minutes)\n",
                  intervalBetweenTx, intervalBetweenTx / 60);

    // üîß Retrieve Calibration Factor
    cal_factor = preferences.getInt("cal_factor", 9999999);
    if (cal_factor == 9999999)
    {
        Serial.println("‚ö†Ô∏è Calibration factor not found! Setting default to 0 üÜï");
        cal_factor = 0;
        preferences.putInt("cal_factor", cal_factor);
    }
    else
    {
        Serial.println("‚úÖ Calibration factor retrieved successfully.");
    }
    Serial.printf("üìè Calibration Factor: %d\n", cal_factor);

    // ‚úÖ Close preferences
    preferences.end();
    Serial.println();
}


void configure_web_server()
{
  Serial.println("üåç Starting Web Server Route Configuration...");

  server.on("/getModeOfOperation", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    DynamicJsonDocument doc(128);
    doc["modeOfOperation"] = modeOfOperation;

    String jsonResponse;
    serializeJson(doc, jsonResponse);
    request->send(200, "application/json", jsonResponse); });

  // Root and static pages
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üìÑ Route: / -> /index.html");
    request->send(SPIFFS, "/index.html", "text/html"); });

  server.on("/index.html", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üìÑ Route: /index.html -> /index.html");
    request->send(SPIFFS, "/index.html", "text/html"); });

  server.on("/analyze.html", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üìÑ Route: /analyze.html -> /analyze.html");
    request->send(SPIFFS, "/analyze.html", "text/html"); });

  server.on("/calibrate.html", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üîß Route: /calibrate.html -> /calibrate.html");
    request->send(SPIFFS, "/calibrate.html", "text/html"); });

  server.on("/wspr.html", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üîß Route: /wspr.html -> WSPR Mode");
    request->send(SPIFFS, "/wspr.html", "text/html"); });

  server.on("/favicon.ico", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üîñ Route: /favicon.ico");
    request->send(SPIFFS, "/favicon.ico", "image/x-icon"); });

  // Static assets
  server.on("/assets/spectrum.jpg", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üñºÔ∏è Route: /assets/spectrum.jpg");
    request->send(SPIFFS, "/assets/spectrum.jpg", "image/jpeg"); });

  server.on("/splash.png", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üñºÔ∏è Route: /splash.png");
    request->send(SPIFFS, "/splash.png", "image/png"); });

  server.on("/assets/wsprlogo.png", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üñºÔ∏è Route: /assets/wsprlogo.png");
    request->send(SPIFFS, "/assets/wsprlogo.png", "image/png"); });
  server.on("/assets/warning.png", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üñºÔ∏è Route: /assets/warning.png");
    request->send(SPIFFS, "/assets/warning.png", "image/png"); });

  server.on("/cesium.key", HTTP_GET, [](AsyncWebServerRequest *request)
            { request->send(SPIFFS, "/cesium.key", "text/plain"); });

  // üîß Settings and data endpoints
  server.on("/getAllSettings", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    preferences.begin("settings", true);
    StaticJsonDocument<256> doc;
    doc["version"] = "Ver. " + String(VERSION);
    doc["callsign"] = preferences.getString("callsign", "");
    doc["locator"] = preferences.getString("locator", "");
    doc["power"] = preferences.getUInt("power", 24);
    doc["TX_referenceFrequ"] = TX_referenceFrequ;
    doc["WSPR_TX_operatingFrequ"] = WSPR_TX_operatingFrequ;
    doc["scheduleState"] = preferences.getString("scheduleState", "schedule1");
    preferences.end();

    String json;
    serializeJson(doc, json);
    request->send(200, "application/json", json); });

  server.on("/getLocator", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    preferences.begin("settings", true);
    String locator = preferences.getString("locator", "");
    preferences.end();

    Serial.println("üì§ Sending Locator...");
    StaticJsonDocument<64> doc;
    doc["locator"] = locator;
    String json;
    serializeJson(doc, json);
    request->send(200, "application/json", json); });

  server.on("/getPower", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    preferences.begin("settings", true);
    uint32_t power = preferences.getUInt("power", 24);
    preferences.end();

    Serial.println("üì§ Sending Power Info...");
    StaticJsonDocument<64> doc;
    doc["power"] = power;
    String json;
    serializeJson(doc, json);
    request->send(200, "application/json", json); });

  server.on("/getTimes", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.printf("üì§ Sending WSPR Timing Info to web page (TX = %d s, Next = %d s)\n", tx_ON_running_time_in_s, currentRemainingSeconds);
    StaticJsonDocument<128> doc;
    doc["currentRemainingSeconds"] = currentRemainingSeconds;
    doc["txRunningTime"] = tx_ON_running_time_in_s;
    doc["TX_referenceFrequ"] = TX_referenceFrequ ;
    doc["intervalBetweenTx"] = intervalBetweenTx;
    String json;
    serializeJson(doc, json);
    request->send(200, "application/json", json); });

  // üîÑ Settings update routes
  server.on("/updateCallsign", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    if (request->hasParam("callsign")) {
      String callsign = request->getParam("callsign")->value();
      preferences.begin("settings", false);
      preferences.putString("callsign", callsign);
      preferences.end();
      Serial.printf("üì° Callsign set to %s\n", callsign.c_str());
    }
    request->send(200, "text/plain", "Callsign updated"); });

  server.on("/updateLocator", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    if (request->hasParam("locator")) {
      String locator = request->getParam("locator")->value();
      preferences.begin("settings", false);
      preferences.putString("locator", locator);
      preferences.end();
      Serial.printf("üìç Locator set to %s\n", locator.c_str());
    }
    request->send(200, "text/plain", "Locator updated"); });

  server.on("/updatePower", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    if (request->hasParam("power")) {
      String power = request->getParam("power")->value();
      preferences.begin("settings", false);
      preferences.putUInt("power", power.toInt());
      preferences.end();
      Serial.printf("‚ö° Power set to %s mW\n", power.c_str());
    }
    request->send(200, "text/plain", "Power updated"); });

  server.on("/updateScheduleState", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    if (request->hasParam("id")) {
      String scheduleState = request->getParam("id")->value();
      preferences.begin("settings", false);
      preferences.putString("scheduleState", scheduleState);
      preferences.end();

      if (scheduleState == "schedule1") intervalBetweenTx = 2 * 60;
      else if (scheduleState == "schedule2") intervalBetweenTx = 4 * 60;
      else if (scheduleState == "schedule3") intervalBetweenTx = 6 * 60;
      else if (scheduleState == "schedule4") intervalBetweenTx = 8 * 60;
      else if (scheduleState == "schedule5") intervalBetweenTx = 10 * 60;
      else intervalBetweenTx = 2 * 60;

      Serial.printf("üìÖ New schedule selected: %s ‚û°Ô∏è Interval set to %d minutes\n", scheduleState.c_str(), intervalBetweenTx / 60);
      isFirstIteration = true;
      interruptWSPRcurrentTX = true;
    } else {
      Serial.println("‚ö†Ô∏è No schedule ID received!");
    }
    request->send(200, "text/plain", "OK"); });

  // üõ†Ô∏è Control and calibration
  server.on("/setFrequency", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üõ†Ô∏è Changing mode of operation to: Analyze (sweeper)");
    interruptWSPRcurrentTX = true;
    modeOfOperation = 5;
    if (request->hasParam("frequency")) {
      String frequencyStr = request->getParam("frequency")->value();
      calFrequencyInMhz = strtoull(frequencyStr.c_str(), NULL, 10);
      setFrequencyInMhz(calFrequencyInMhz);
      Serial.printf("üì° Frequency set to %s Hz and clock powered ON.\n", formatFrequencyWithDots(calFrequencyInMhz * 1e6).c_str());
    }
    request->send(200, "text/plain", "Frequency and clock power set"); });

  server.on("/updateCalFactor", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    if (request->hasParam("calFactor")) {
      cal_factor = request->getParam("calFactor")->value().toInt();
      si5351.set_correction(cal_factor, SI5351_PLL_INPUT_XO);
      Serial.printf("üìè Calibration factor set to %d\n", cal_factor);
    }
    request->send(200, "text/plain", "Calibration factor updated"); });

  server.on("/saveCalFactor", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    modeOfOperation = 2;
    isFirstIteration = true;
    if (request->hasParam("calFactor")) {
      cal_factor = request->getParam("calFactor")->value().toInt();
      preferences.begin("settings", false);
      preferences.putInt("cal_factor", cal_factor);
      preferences.end();
      Serial.printf("\nüìè Calibration factor saved: %d\n", cal_factor);
      si5351.set_clock_pwr(SI5351_CLK0, 0);  // TX OFF
      Serial.println("‚úÖ Exiting Calibration Mode, WSPR TX Resumed.");
    }
    request->send(200, "text/plain", "Calibration factor saved"); });

  server.on("/getCalFactor", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.printf("üì§ Sending Calibration Factor: %d\n", cal_factor);
    request->send(200, "text/plain", String(cal_factor)); });

  // Reboot and reset
  server.on("/reboot", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("üîÑ Reboot requested...");
    request->send(200, "text/plain", "Rebooting...");
    delay(1000);
    ESP.restart(); });

  server.on("/factoryReset", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    Serial.println("‚ö†Ô∏è Factory Reset Requested...");
    request->send(200, "text/plain", "Factory reset...");
    delay(1000);
    preferences.begin("settings", false);
    preferences.clear();
    preferences.end();
    ESP.restart(); });

  server.begin();
  Serial.println("‚úÖ Web Server Routes Configuration Completed!");
}
void setFrequencyInMhz(float freqMHz)
{
  Serial.println("‚öôÔ∏è Setting frequency on SI5351...");

  // Power down Clock before reconfiguring
  si5351.set_clock_pwr(SI5351_CLK0, 0);
  Serial.println("üîå Clock powered OFF");

  // Convert MHz to Hz
  uint64_t freq = (uint64_t)(freqMHz * 1e6);
  Serial.print("üì° Target frequency: ");
  Serial.print(freqMHz, 6); // show with precision
  Serial.println(" MHz");

  // Set frequency (multiply by 100 for 100ths of Hz resolution)
  si5351.set_freq(freq * 100ULL, SI5351_CLK0);
  Serial.println("üì∂ Frequency set successfully");

  // Power on Clock
  si5351.set_clock_pwr(SI5351_CLK0, 1);
  Serial.println("‚úÖ SI5351 Clock powered ON");
}
